-------------------- A2: Objektorienterad abstraktion ------------------------ 

Vad behöver klasserna veta om de andra klasserna de använder?

	De andra klasserna behöver på en teknisk nivå bara veta vad de andra klassernas metoder tar som input och returnerar.
	Men för att använda modulen bör man veta fler saker, som vad de har för fält. 
	Och bättre dokumentation, om det finns invalida input.
	
Vad är procedurell abstraktion?

	Vi skapar datastrukturer och funktioner, ber funktioner göra saker med data som input. 
	
Vad är objekt-orienterad abstraktion

	Vi skapar objekt som har information och kan göra saker med sig själva

	Vi kan skapa abstrakta klasser, vilket innebär att vi säger att "detta är ett fordon"
	Men vi kan inte skapa ett fordon, för det är för vagt. Vi får då ha subklasser cykel, bil, traktor osv.
	Så när vi skapar ett fordon måste det anta formen av någon av dess subklasser.
	Detta bra abstraktion då vi kan ha beteende som delas av alla fordon, då slipper vi skriva de metoderna på flera ställen.

Likheter mellan objekt-orienterad och procedurell abstraktion

	Det handlar båda om att gömma information som inte behövs för att använda koden.

På vilket sätt skiljer sig ett typiskt C-program från ett Java-program?

	hur man går tillväga för att skriva programmet är fundamentalt annorlunda.

På vilket sätt är de lika?

	I båda så definierar vi ett gäng funktioner som hör till en viss del av programmet. Har sedan en main-funktion 
	i någon del som kör själva programmet med hjälp av funktionerna.
	
Varför det är vettigt att identifiera liknande mönster i koden och extrahera dem och kapsla in dem i en enda procedur som kan anropas istället för upprepningarna?

	Bättre för läsbarhet, att hitta och förstå kod, lättare att pin-pointa buggar samt att ändra i koden.
	
Vad innebär egentligen objekt-orienterad programmering? 

	Det som står i målet, att istället för att säga till ett program att genomföra operationer med olika värden.
	Så skapar vi objekt som har 1. egenskaper 2. saker de kan göra (ofta med sig själva)
	
Förstår inte riktigt vad gränssnitt har med saken att göra.
	
	Gränssnitt är hur två delar/moduler/filer interagerar. Alltså vad en del kan använda från en annan del.	
	
Förstår inte hur de föreslår att man kan ta detta mål med lab7, där vi inte skapar några abstrakta klasser.
	
	
------------------------ G16: Namn-baserad inkapsling -------------------------

Vilka attribut ska vara synliga utifrån?

	Så få som möjligt. I mitt fall absolut inga. 
	Jag hade ett par som inte var private, testade sätta de till private och kompilera samt köra.
	Det funkade galant, vilket får mig att ställa mig frågan: varför skulle jag inte göra det?
	
Jämför att ha privata attribut med getters och setters med att bara ha publika attribut.

	Att ha publika attribut skulle innebära att jag kan ändra på objekts attribut från alla andra moduler.
	Detta är inte att föredra eftersom då kan delar av programmet som inte borde kunna ändra på objektet göra direkta förändringar.
	Då ger det bättre kontroll att ha getters, som bara hämtar värdet på ett fält hos objektet.
	Och setters som möjligtvis ändrar värdet (men bara om vi skapar en sådan metoder, för att vi vill ha den funktionaliteten.
	Då kan vi kontrollera I DEN FILEN vad vi vill kunna ändra på och vilken information andra klasser ska få veta.
	
Vad är Javas standard för inkapsling? Är det vettigt? Varför/varför inte?

	Att gömma all information som inte behövs. 
	Ja det är vettigt för att det blir lättare att förstå och använda informationen som ÄR nödvändig.
	Och dra av alla anledningar som abstraktion är bra för.
	
private används för alla attribut i mitt program. public används för alla metoder, förutom t.ex next() i Queue, för det är bara en hjälpfunktion. Protected behövs inte, för jag jobbar inte med packages.
